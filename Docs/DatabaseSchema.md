# Poseidon API Orchestrator - Database Schema

Welcome to the **Poseidon API Orchestrator Database Schema** documentation. This guide provides a detailed overview of the MongoDB collections utilized by the Poseidon API, outlining the structure, fields, indexes, and sample documents. Whether you're a developer working on the backend, a database administrator, or a new contributor, this document will help you understand and interact with the database effectively.

---

## Table of Contents

1. [Introduction](#introduction)
2. [Collections Overview](#collections-overview)
   - [Passengers Collection](#passengers-collection)
   - [Users Collection](#users-collection)
   - [Tokens Collection](#tokens-collection)
3. [Field Descriptions](#field-descriptions)
   - [Passenger Fields](#passenger-fields)
   - [User Fields](#user-fields)
   - [Token Fields](#token-fields)
4. [Indexes](#indexes)
   - [Passengers Collection Indexes](#passengers-collection-indexes)
   - [Users Collection Indexes](#users-collection-indexes)
5. [Relationships](#relationships)
6. [Sample Documents](#sample-documents)
   - [Passenger Document](#passenger-document)
   - [User Document](#user-document)
   - [Token Document](#token-document)
7. [Best Practices](#best-practices)
8. [Conclusion](#conclusion)

---

## 1. Introduction

The **Poseidon API Orchestrator** leverages **MongoDB**, a NoSQL database, to store and manage data efficiently. Unlike traditional relational databases, MongoDB uses collections to store documents in a flexible, JSON-like format (BSON), allowing for dynamic schemas and scalability.

This document outlines the schema and structure of the key collections in MongoDB used by the Poseidon API:

- **Passengers**: Stores detailed information about Titanic passengers.
- **Users**: Manages user accounts, including authentication data.
- **Tokens**: (Optional) Handles JWT tokens for session management and authentication.

Understanding the database schema is crucial for effective data management, query optimization, and maintaining the integrity of the application.

---

## 2. Collections Overview

### **Passengers Collection**

- **Collection Name**: `passengers`
- **Description**: Contains comprehensive data for each passenger aboard the Titanic, including personal details, travel class, fare information, and survival status.

- **Document Example**:

  ```json
  {
    "_id": "60d5b2c2b45e3d5f348f5b76",
    "survived": true,
    "pclass": 1,
    "name": "John Doe",
    "sex": "male",
    "age": 35,
    "siblingsOrSpousesAboard": 1,
    "parentsOrChildrenAboard": 0,
    "fare": 85.50
  }
  ```

### **Users Collection**

- **Collection Name**: `users`
- **Description**: Manages user accounts, including usernames, emails, hashed passwords, and roles (Admin/User). This collection is essential for authentication and authorization processes.

- **Document Example**:

  ```json
  {
    "_id": "60d5b2d3b45e3d5f348f5b79",
    "username": "admin_user",
    "email": "admin@example.com",
    "password": "$2a$12$34ksdja38...",
    "role": "Admin"
  }
  ```

### **Tokens Collection** (Optional)

- **Collection Name**: `tokens`
- **Description**: Stores JWT tokens associated with user sessions. This allows for session management, token validation, and expiration handling.

- **Document Example**:

  ```json
  {
    "_id": "60d5b2e4b45e3d5f348f5b82",
    "userId": "60d5b2d3b45e3d5f348f5b79",
    "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
    "expirationDate": "2024-09-22T10:12:24.000Z"
  }
  ```

---

## 3. Field Descriptions

### **Passenger Fields**

| Field                      | Type     | Description                                                                                           |
|----------------------------|----------|-------------------------------------------------------------------------------------------------------|
| `_id`                      | `ObjectId` | Unique identifier for each passenger document, auto-generated by MongoDB.                             |
| `survived`                 | `boolean` | Indicates whether the passenger survived (`true`) or did not survive (`false`) the Titanic sinking.  |
| `pclass`                   | `int`     | Passenger class (`1` = First Class, `2` = Second Class, `3` = Third Class).                          |
| `name`                     | `string`  | Full name of the passenger.                                                                           |
| `sex`                      | `string`  | Gender of the passenger (`male` or `female`).                                                         |
| `age`                      | `double`  | Age of the passenger. Can be `null` if unknown.                                                       |
| `siblingsOrSpousesAboard`  | `int`     | Number of siblings or spouses the passenger had aboard the Titanic.                                   |
| `parentsOrChildrenAboard`  | `int`     | Number of parents or children the passenger had aboard the Titanic.                                   |
| `fare`                     | `double`  | Fare paid by the passenger for their ticket. Can be `null` if unknown.                                |

### **User Fields**

| Field     | Type     | Description                                                                                      |
|-----------|----------|--------------------------------------------------------------------------------------------------|
| `_id`     | `ObjectId` | Unique identifier for each user document, auto-generated by MongoDB.                              |
| `username`| `string`  | Unique username selected by the user.                                                            |
| `email`   | `string`  | User's email address. Must be unique.                                                            |
| `password`| `string`  | Hashed password for user authentication (hashed using a secure algorithm like bcrypt).           |
| `role`    | `string`  | Role of the user (`Admin` or `User`). Admins have elevated permissions.                         |

### **Token Fields** (Optional)

| Field            | Type     | Description                                                                                               |
|------------------|----------|-----------------------------------------------------------------------------------------------------------|
| `_id`            | `ObjectId` | Unique identifier for each token document, auto-generated by MongoDB.                                     |
| `userId`         | `ObjectId` | Reference to the `users` collection's `_id` field, indicating which user the token belongs to.            |
| `token`          | `string`  | The JWT token string issued during user login.                                                           |
| `expirationDate` | `date`    | Expiration date and time for the token, after which the user will need to re-authenticate.                |

---

## 4. Indexes

Indexes are crucial for optimizing query performance and ensuring efficient data retrieval. Below are the recommended indexes for each collection in the Poseidon API.

### **Passengers Collection Indexes**

| Index Name      | Fields               | Type       | Description                                               |
|-----------------|----------------------|------------|-----------------------------------------------------------|
| `_id_`          | `_id`                | Ascending  | **Default Index**: Automatically created by MongoDB. Used as the primary key. |
| `pclass_1`      | `pclass`             | Ascending  | Speeds up queries filtering passengers by class.          |
| `survived_1`    | `survived`           | Ascending  | Enhances performance for queries filtering by survival status. |
| `name_1`        | `name`               | Text       | Facilitates text search on passenger names.               |
| `sex_1`         | `sex`                | Ascending  | Improves query performance when filtering by gender.      |

### **Users Collection Indexes**

| Index Name       | Fields       | Type      | Description                                               |
|------------------|--------------|-----------|-----------------------------------------------------------|
| `_id_`           | `_id`        | Ascending | **Default Index**: Automatically created by MongoDB. Used as the primary key. |
| `email_1`        | `email`      | Unique    | Ensures uniqueness of email addresses and speeds up lookup by email. |
| `username_1`     | `username`   | Unique    | Ensures uniqueness of usernames and accelerates queries by username. |

### **Tokens Collection Indexes** (Optional)

| Index Name           | Fields        | Type      | Description                                                                 |
|----------------------|---------------|-----------|-----------------------------------------------------------------------------|
| `_id_`               | `_id`         | Ascending | **Default Index**: Automatically created by MongoDB. Used as the primary key. |
| `userId_1`           | `userId`      | Ascending | Facilitates quick lookup of tokens by user ID.                              |
| `token_1`            | `token`       | Unique    | Ensures each token is unique and allows fast validation of tokens.          |
| `expirationDate_1`   | `expirationDate` | Ascending | Speeds up queries for tokens nearing expiration, useful for cleanup tasks. |

---

## 5. Relationships

While MongoDB is a NoSQL database and doesn't enforce relationships like traditional relational databases, understanding the logical connections between collections is essential for data integrity and efficient querying.

### **Users and Tokens**

- **Relationship**: One-to-Many
- **Description**: Each user can have multiple tokens, representing different sessions or devices. The `userId` field in the `tokens` collection references the `_id` field in the `users` collection.
- **Usage**: Useful for managing user sessions, token revocation, and ensuring that tokens are associated with the correct user.

---

## 6. Sample Documents

Understanding the structure of documents within each collection is vital for developers interacting with the database. Below are sample documents for each collection.

### **Passenger Document**

```json
{
  "_id": "60d5b2c2b45e3d5f348f5b76",
  "survived": true,
  "pclass": 1,
  "name": "John Doe",
  "sex": "male",
  "age": 35,
  "siblingsOrSpousesAboard": 1,
  "parentsOrChildrenAboard": 0,
  "fare": 85.50
}
```

### **User Document**

```json
{
  "_id": "60d5b2d3b45e3d5f348f5b79",
  "username": "admin_user",
  "email": "admin@example.com",
  "password": "$2a$12$34ksdja38...",
  "role": "Admin"
}
```

### **Token Document** (Optional)

```json
{
  "_id": "60d5b2e4b45e3d5f348f5b82",
  "userId": "60d5b2d3b45e3d5f348f5b79",
  "token": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...",
  "expirationDate": "2024-09-22T10:12:24.000Z"
}
```

---

## 7. Best Practices

To maintain an efficient, secure, and scalable database, adhere to the following best practices:

### **Data Validation**

- **Schema Validation**: Even though MongoDB is schema-less, implementing validation rules using MongoDB's JSON Schema can prevent invalid data entries.
- **Application-Level Validation**: Ensure that the application enforces data integrity before inserting or updating documents in the database.

### **Index Management**

- **Use Indexes Wisely**: While indexes speed up read operations, they can slow down write operations. Only index fields that are frequently queried.
- **Monitor Index Performance**: Use MongoDB's performance monitoring tools to assess the effectiveness of your indexes and make adjustments as necessary.

### **Security Measures**

- **Secure Credentials**: Store sensitive information like database credentials and JWT secrets securely using environment variables, Kubernetes Secrets, or dedicated secret management tools.
- **Access Control**: Implement proper access controls and roles within MongoDB to restrict data access based on user permissions.

### **Data Backup and Recovery**

- **Regular Backups**: Schedule regular backups of your MongoDB data to prevent data loss.
- **Test Recovery Procedures**: Periodically test your backup and recovery processes to ensure data can be restored effectively when needed.

### **Performance Optimization**

- **Optimize Queries**: Write efficient queries that leverage indexes and avoid full collection scans where possible.
- **Sharding and Replication**: For large-scale applications, consider implementing sharding and replication to distribute the database load and ensure high availability.

### **Documentation and Consistency**

- **Maintain Updated Documentation**: Keep the database schema documentation up-to-date with any changes to the collections or fields.
- **Consistent Naming Conventions**: Use consistent naming conventions for collections and fields to enhance readability and maintainability.

---

## 8. Conclusion

This **Database Schema** document provides a thorough understanding of the MongoDB collections utilized by the **Poseidon API Orchestrator**. By adhering to the outlined structures, field definitions, and best practices, you can ensure efficient data management, optimal performance, and robust security within your application.

For further details or questions regarding the database schema, feel free to consult the [API Documentation](./Docs/APIDocumentation.md) or reach out to the project maintainers through the [Poseidon GitHub Repository](https://github.com/cheloghm/Poseidon).

---

## Additional Steps and Notes

1. **Integrate with ORM/ODM**

   - If using an Object-Document Mapper (ODM) like **Mongoose** or **MongoDB's .NET Driver**, ensure that your models accurately reflect the database schema.
   - Implement data annotations or validation rules within your models to enforce schema consistency.

2. **Automate Schema Updates**

   - Utilize migration tools or scripts to handle schema changes systematically, reducing the risk of inconsistencies.
   - Version your database schema to track changes over time.

3. **Monitor Database Performance**

   - Use MongoDB's monitoring tools such as **MongoDB Atlas** or **Prometheus** with **Grafana** to keep an eye on database performance metrics.
   - Identify and address bottlenecks proactively to maintain optimal application performance.

4. **Handle Optional Collections**

   - The `tokens` collection is optional and used for advanced session management. Assess whether your application requires this feature and implement it accordingly.
   - If not needed, consider omitting the `tokens` collection to simplify the database structure.

5. **Data Consistency**

   - Implement referential integrity at the application level since MongoDB does not enforce foreign key constraints.
   - Use transactions for operations that require atomicity across multiple collections.

6. **Regular Audits**

   - Periodically review your database for unused indexes, deprecated fields, or data inconsistencies.
   - Clean up obsolete data to maintain a lean and efficient database.

7. **Scalability Considerations**

   - As your application grows, monitor the scalability of your database setup.
   - Consider deploying MongoDB in a clustered environment with **Replica Sets** and **Sharding** to handle increased load and ensure data redundancy.

---
